#![feature(lazy_cell)]

//! This crate exposes an interface to setup provers and verifiers for Scroll's proof generation
//! pipeline.
//!
//! Scroll's proof generation pipeline implements a [layered][config::LayerId] approach where
//! [`SNARK(s)`][snark_verifier_sdk::Snark] from a layer is (are) used in the subsequent layer.
//!
//! A high-level abstraction has been implemented with the notion of:
//! - Block: Consists of a list of txs
//! - Chunk: Composed of a list of contiguous Blocks
//! - Batch: Composed of a list of contiguous Chunks
//! - Bundle: Composed of a list of contiguous Batches
//!
//! The proof generation pipeline starts at the `Chunk` level where the inner proof can be
//! generated either via the halo2-route or the sp1-route, aka [`ChunkKind`].
//!
//! The pipeline for the halo2-route is described below:
//! 1. [`Inner`][config::LayerId::Inner] layer: SNARK generated by halo2-based
//!    [`SuperCircuit`][zkevm_circuits::super_circuit::SuperCircuit]
//! 2. [`Layer-1`][config::LayerId::Layer1]: Inner SNARK compressed by the [`CompressionCircuit`]
//!    configured with a wide shape, i.e. higher advices for a lower degree
//! 3. [`Layer-2`][config::LayerId::Layer2]: Layer-1 SNARK compressed by the `CompressionCircuit`
//!    with a thin shape, i.e. higher degree for lower advices
//!
//! The pipeline for the sp1-route is described below:
//! 1. [`Inner`][config::LayerId::Inner] layer: Sp1 compressed proof generated via the Sp1 Prover.
//! 2. [`Layer-1`][config::LayerId::Layer1]: Inner STARK is SNARKified using a halo2-backend.
//! 3. [`Layer-2`][config::LayerId::Layer2]: Layer-1 SNARK compressed by the `CompressionCircuit`
//!    with a thin shape, i.e. higher degree for lower advices
//!
//! For both of the above described branches, we continue the pipeline with:
//! 4. [`Layer-3`][config::LayerId::Layer3]: List of Layer-2 SNARKs aggregated using the
//!    [`BatchCircuit`]
//! 5. [`Layer-4`][config::LayerId::Layer4]: Layer-3 SNARK compressed by the `CompressionCircuit`
//! 6. [`Layer-5`][config::LayerId::Layer5]: Layer-4 SNARKs are recursively aggregated using the
//!    [`RecursionCircuit`]
//! 7. [`Layer-6`][config::LayerId::Layer6]: Layer-5 SNARK is compressed by the
//!    `CompressionCircuit` with a thin shape, while using Keccak hasher as the transcript digest
//!    to allow verification of Layer-6 proof in EVM.

mod aggregator;
pub use aggregator::{
    check_chunk_hashes, eip4844, BatchData, BatchHash, BatchHeader, BatchProver, BatchProverError,
    BatchVerifier, RecursionTask, MAX_AGG_SNARKS,
};

mod common;
pub use common::{ChunkInfo, CompressionCircuit, Prover, Verifier};

mod config;
pub use config::*;

mod consts;
pub use consts::*;

mod evm;
pub use evm::deploy_and_call;

mod inner;
pub use inner::*;

mod io;
pub use io::*;

mod proof;
pub use proof::{BatchProof, BundleProof, ChunkKind, ChunkProof, EvmProof, Proof};

mod test;
pub use test::{batch_prove, bundle_prove, chunk_prove, inner_prove};

mod types;
pub use types::{BatchProvingTask, BundleProvingTask, ChunkProvingTask, WitnessBlock};

mod utils;
pub use utils::*;

mod zkevm;
pub use zkevm::{ChunkProver, ChunkProverError, ChunkVerifier, CircuitCapacityChecker};

/// Re-export the eth-types crate.
pub use eth_types;

/// Re-export some types from snark-verifier-sdk.
pub use snark_verifier_sdk::{CircuitExt, Snark};

/// Re-export the zkevm-circuits crate.
pub use zkevm_circuits;

use halo2_proofs::{halo2curves::bn256::Bn256, poly::kzg::commitment::ParamsKZG};
use std::collections::BTreeMap;

/// Alias for convenience.
pub type ParamsMap = BTreeMap<u32, ParamsKZG<Bn256>>;
