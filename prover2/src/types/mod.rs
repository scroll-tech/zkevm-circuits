use aggregator::{AggregationCircuit, ChunkInfo, CompressionCircuit};
use ethers_core::types::H256;
use halo2_proofs::{
    halo2curves::bn256::{Bn256, Fr},
    poly::kzg::commitment::ParamsKZG,
};
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use snark_verifier_sdk::{CircuitExt, Snark};
use zkevm_circuits::super_circuit::params::ScrollSuperCircuit;

use crate::{
    types::{layer::ProofLayer, task::ProvingTask},
    ProverError,
};

pub mod layer;

pub mod proof;

pub mod task;
use task::{BatchProvingTask, ChunkProvingTask};

/// Defines the behaviour that a prover type must implement.
///
/// The proof generation process involves the following steps:
/// 1. [`ProverTypeChunk`]: prove the EVM execution trace from a list of blocks ([`layer0`][layer0])
///    and compress it twice ([`layer1`][layer1] and [`layer2`][layer2]), where the outermost proof
///    (`layer2`) is the `ChunkProof`.
/// 2. [`ProverTypeBatch`]: prove the batching of one or more chunks ([`layer3`][layer3])
///    and compress it ([`layer4`][layer4]) where this outermost proof (`layer4`) is the `BatchProof`.
/// 3. [`ProverTypeBundle`]: prove the bundling of one or more batches recursively ([`layer5`][layer5])
///    and compress it ([`layer6`][layer6]) where this outermost proof (`layer6`) is the `BundleProof`.
///    The `BundleProof` is an EVM-verifiable proof.
///
/// [layer0]: crate::types::layer::ProofLayer::Layer0
/// [layer1]: crate::types::layer::ProofLayer::Layer1
/// [layer2]: crate::types::layer::ProofLayer::Layer2
/// [layer3]: crate::types::layer::ProofLayer::Layer3
/// [layer4]: crate::types::layer::ProofLayer::Layer4
/// [layer5]: crate::types::layer::ProofLayer::Layer5
/// [layer6]: crate::types::layer::ProofLayer::Layer6
pub trait ProverType: std::fmt::Debug {
    /// The name of the prover.
    const NAME: &'static str;

    /// The proving task that provides the relevant values required by the prover type to build its
    /// base circuit.
    type Task: ProvingTask;

    /// The circuit used at the base layer of this prover type.
    type BaseCircuit: CircuitExt<Fr>;

    /// The [`Compression Circuit`][compr_circuit] used to compress the base layer
    /// [`SNARK`][snark] one or more times before finally producing the outermost
    /// layer's SNARK.
    ///
    /// [snark]: snark_verifier_sdk::Snark
    /// [compr_circuit]: aggregator::CompressionCircuit
    type CompressionCircuit: CircuitExt<Fr>;

    /// The auxiliary data attached to the [`Proof`][proof] from the prover type.
    /// For instance, a [`ChunkProver`][chunk_prover] needs to attach the [`ChunkInfo`],
    /// which is then used by the [`BatchProver`][batch_prover] to construct its
    /// [`BatchProvingTask`].
    ///
    /// [proof]: crate::types::proof::Proof
    /// [chunk_prover]: crate::prover::ChunkProver
    /// [batch_prover]: crate::prover::BatchProver
    type ProofAuxData: Serialize + DeserializeOwned + std::fmt::Debug;

    /// The prover supports proof generation at the following layers.
    fn layers() -> Vec<ProofLayer>;

    /// Returns the base layer. The base layer's proof is generated by building the
    /// [`BaseCircuit`][base_circuit].
    ///
    /// [base_circuit]: Self::BaseCircuit
    fn base_layer() -> Result<ProofLayer, ProverError> {
        Self::layers()
            .first()
            .ok_or(ProverError::Custom(format!("no layer for {}", Self::NAME)))
            .copied()
    }

    /// Returns the outermost layer. This is generally the last compression layer of the prover
    /// type.
    fn outermost_layer() -> Result<ProofLayer, ProverError> {
        Self::layers()
            .last()
            .ok_or(ProverError::Custom(format!("no layer for {}", Self::NAME)))
            .copied()
    }

    /// Returns the subsequent layers after the base layer, i.e. the layers where the previous
    /// layer's SNARK is compressed.
    fn compression_layers() -> Vec<ProofLayer> {
        Self::layers()[1..].to_vec()
    }

    /// Builds the [`BaseCircuit`][base_circuit] given witness in the proving task.
    ///
    /// [base_circuit]: Self::BaseCircuit
    fn build_base(task: &Self::Task) -> (Self::BaseCircuit, Self::ProofAuxData);

    /// Builds the [`CompressionCircuit`][compr_circuit] given the previous layer's SNARK.
    ///
    /// [compr_circuit]: Self::CompressionCircuit
    fn build_compression(
        kzg_params: &ParamsKZG<Bn256>,
        prev_snark: Snark,
        layer: ProofLayer,
    ) -> Self::CompressionCircuit;
}

/// The chunk prover that constructs proofs at [`layer0`][layer0], [`layer1`][layer1] and [`layer2`][layer2].
///
/// [layer0]: crate::types::layer::ProofLayer::Layer0
/// [layer1]: crate::types::layer::ProofLayer::Layer1
/// [layer2]: crate::types::layer::ProofLayer::Layer2
#[derive(Default, Debug)]
pub struct ProverTypeChunk;

/// The batch prover that constructs proofs at [`layer3`][layer3] and [`layer4`][layer4].
///
/// [layer3]: crate::types::layer::ProofLayer::Layer3
/// [layer4]: crate::types::layer::ProofLayer::Layer4
#[derive(Default, Debug)]
pub struct ProverTypeBatch<const N_SNARKS: usize>;

/// The bundle prover that constructs proofs at [`layer5`][layer5] and [`layer6`][layer6].
///
/// [layer5]: crate::types::layer::ProofLayer::Layer5
/// [layer6]: crate::types::layer::ProofLayer::Layer6
#[derive(Default, Debug)]
pub struct ProverTypeBundle;

/// Auxiliary data attached to a [`ChunkProof`][proof]
///
/// [proof]: crate::types::proof::Proof
#[derive(Serialize, Deserialize, Debug)]
pub struct ChunkProofAuxData {
    /// The chunk's information, that is eventually needed by the [`BatchProver`][batch_prover]'s
    /// proof generation process.
    ///
    /// [batch_prover]: crate::prover::BatchProver::gen_proof
    pub chunk_info: ChunkInfo,
}

/// Auxiliary data attached to a [`BatchProof`][proof]
///
/// [proof]: crate::types::proof::Proof
#[derive(Serialize, Deserialize, Debug)]
pub struct BatchProofAuxData {
    /// The hash of the [`BatchHeader`][batch_header]
    ///
    /// [batch_header]: aggregator::BatchHeader
    pub batch_hash: H256,
}

impl ProverType for ProverTypeChunk {
    const NAME: &'static str = "ChunkProver";

    type Task = ChunkProvingTask;

    type BaseCircuit = ScrollSuperCircuit;

    type CompressionCircuit = CompressionCircuit;

    type ProofAuxData = ChunkProofAuxData;

    fn layers() -> Vec<ProofLayer> {
        vec![ProofLayer::Layer0, ProofLayer::Layer1, ProofLayer::Layer2]
    }

    fn build_base(_task: &Self::Task) -> (Self::BaseCircuit, Self::ProofAuxData) {
        unimplemented!()
    }

    fn build_compression(
        _params: &ParamsKZG<Bn256>,
        _prev_snark: Snark,
        _layer: ProofLayer,
    ) -> Self::CompressionCircuit {
        unimplemented!()
    }
}

impl<const N_SNARKS: usize> ProverType for ProverTypeBatch<N_SNARKS> {
    const NAME: &'static str = "BatchProver";

    type Task = BatchProvingTask<N_SNARKS>;

    type BaseCircuit = AggregationCircuit<N_SNARKS>;

    type CompressionCircuit = CompressionCircuit;

    type ProofAuxData = BatchProofAuxData;

    fn layers() -> Vec<ProofLayer> {
        vec![ProofLayer::Layer3, ProofLayer::Layer4]
    }

    fn build_base(_task: &Self::Task) -> (Self::BaseCircuit, Self::ProofAuxData) {
        unimplemented!()
    }

    fn build_compression(
        _params: &ParamsKZG<Bn256>,
        _prev_snark: Snark,
        _layer: ProofLayer,
    ) -> Self::CompressionCircuit {
        unimplemented!()
    }
}
